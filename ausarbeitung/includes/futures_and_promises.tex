\section{Futures und Promises}

\subsection{Motivation}

\paragraph{Blockierende Methodenaufrufe} Methodenaufrufe in üblichen Programmiersprachen sind blockierend. Das bedeutet,
dass das Hauptprogramm solange blockiert wird, wie der Methodenaufruf läuft.
So wird in Listing \ref{lst:codeBlocking} die Methode \texttt{tuEtwas()} eines Objektes aufgerufen.

\begin{lstlisting}[caption={Blockierender Methodenaufruf},label={lst:codeBlocking},captionpos=b]
main() {
  objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \fbox{
	\includegraphics[scale=0.7]{pic/BlockingCall.png}
  }
  \caption{Ein blockierender Methodenaufruf }
  \label{blockingCall}
\end{figure}

In Abbildung \ref{blockingCall} wird dieser Sachverhalt graphisch
dargestellt: Da der Aufruf blockiert kann immer nur ein Thread
arbeiten (in der Abbidlung grün).

\paragraph{Nicht-blockierende Methodenaufrufe} Führen wir das Schlüsselwort
\texttt{nebenlaeufig} in unseren Pseudocode ein,
können wir ausdrücken, dass die aufgerufene Methode nicht blockieren soll
und im Hauptthread weitergearbeitet werden kann.

\begin{lstlisting}[caption={Nebenläufiger Methodenaufruf},label={lst:codeConcurrent},captionpos=b]
main() {
  nebenlaeufig objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

\begin{figure}[htbp]
  \centering
  \fbox{
	\includegraphics[scale=0.7]{pic/NonBlockingCall.png}
  }
  \caption{Ein nicht blockierender Methodenaufruf }
  \label{nonBlockingCall}
\end{figure}

Nun kann \texttt{tuEtwasAnderes()} \emph{nebenläufig} ausgeführt werden. Damit
ist es bei mehreren Prozessoren möglich, den Code parallel auszuführen.

Abbildung \ref{nonBlockingCall} zeigt das gewünschte Verhalten:
Es entstehen zwei Threads die gleichzeitig ausgeführt werden können,
wenn die Hardware dazu in der Lage ist.

Eine Analogie aus dem IT-Umfeld sind Unix-Shells. Wenn zum Beispiel ein
\texttt{find}-Befehl ausgeführt wird, blockiert die Shell bis der Befehl
abgeschlossen ist. Durch Anhängen eines kaufmännischen \glqq und\grqq{}-Zeichens 
ist es möglich,
den Befehl im Hintergrund laufen zu lassen. Dadurch kann im selben
Terminal weiter gearbeitet werden während der Befehl im Hintergrund (also nebenläufig)
läuft.

\subsection{Futures}

Im SIP-14 wird ein \emph{Future} wie folgt beschrieben:
\begin{quote}
Futures provide a nice way to reason about performing many operations in 
parallel – in an efficient and non-blocking way. The idea is simple, a Future 
is a sort of placeholder object that you can create for a result that doesn’t 
yet exist. Generally, the result of the Future is computed concurrently and can 
be later collected. Composing concurrent tasks in this way tends to result in 
faster, asynchronous, non-blocking parallel code.

A Future object either holds a result of a computation or an 
exception in the case that the computation failed.
\end{quote}

Das Ziel ist es, einen angenehmen Weg zu schaffen um nicht
blockierend (\glqq non-blocking\grqq{}) zu programmieren.

Alles was innerhalb eines \emph{Futures} passiert läuft nicht im
Hauptthread.

\paragraph{Einfaches Beispiel in Pseudocode}

\lstinputlisting
    [caption={Pseudocode zum Minimalbeispiel eines Futures },
       label = lst:scala_mini_future,
       captionpos=b]
 {../code/minimal/future/Future.pseudo}
 
In Listing \ref{lst:scala_mini_future} ist der Umgang mit einem \emph{Future}
skizziert. Sie sind generische Typen, es ist also möglich \emph{Futures}
zu verwenden, die beliebige Typen beinhalten. Der Code des \emph{Futures}
wird innerhalb des \texttt{future \{ ... \}}-Blocks definiert. Der
Rückgabewert muss dem Typen entsprechen, den der \emph{Future} zurückgibt.

\subsection{Promises}

Ein \emph{Promise} hingegen wird im SIP-14 folgendermaßen beschrieben:
\begin{quote}
A promise can be thought of as a writeable, single-assignment container, which 
completes a future. That is, a promise can be used to successfully complete a 
future with a value (by \glqq completing\grqq{} the promise) using the \texttt{success} method. 
Conversely, a promise can also be used to complete a future with an exception, 
by failing the promise, using the \texttt{failure} method.
\end{quote}

Das Konzept \emph{Promise} baut auf den \emph{Futures} auf. Es bietet
einmaligen Schreibzugriff auf ein Objekt, das zum gegebenen Zeitpunkt
noch nicht beschrieben werden kann, zum Beispiel weil dieser Wert
noch nicht berechnet worden ist.

Er befindet sich immer in einem von zwei Zuständen:
\begin{itemize}
 \item{\textbf{\emph{Unerledigt}} Es wurde noch keine Ergebnisse in den Promise geschrieben.}
 \item{\textbf{\emph{Erledigt}} Der Promise wurde abgeschlossen. Entweder durch ein.}
 ergebnis oder durch eine Exception.
\end{itemize}

\paragraph{Einfaches Beispiel in Pseudocode}

\lstinputlisting
    [caption={Pseudocode zum Minimalbeispiel eines Promises },
       label = lst:scala_mini_promise,
       captionpos=b]
 {../code/minimal/promise/Promise.pseudo}
 
Im Beispiel in Listing \ref{lst:scala_mini_promise} ist ein \emph{Promise} zu sehen.
Jedes \emph{Promise} beinhaltet ein \emph{Future}. Im Programm kann
so lange gerechnet werden, bis der Wert mit dem das \emph{Promise}
vervollständigt werden kann, verfügbar ist. Im Beispiel ist dieser
Wert der Einfachheit halber hart codiert, in der Praxis wird er das
nicht sein.

\paragraph{Vergleich} von \emph{Futures} und \emph{Promises}.

\begin{table}[h]
\begin{tabular}{lllll}
 & \textbf{Eigenschaft} & \textbf{Future} & \textbf{Promise} &  \\
 & Lesbar (mehrfach) & Ja & Nein &  \\
 & Schreibbar (einmal) & Nein & Ja &  \\
 & Beinhaltet anderen & Nein & Ja &  \\
 &  &  &  &  \\
 &  &  &  &  \\
 &  &  &  & 
\end{tabular}
\end{table}

\subsection{Kombinatoren}

\paragraph{Motivation} Kombinatoren werden in der offiziellen 
\emph{Scala}-Dokumentation beschrieben (vgl.: \cite{scalaDokuFP}).
Sie erlauben es, mehrere \emph{Futures} zu verbinden. 
Auf diese Weise können komplexe Zusammenhänge relativ einfach
im Code formuliert werden.

Eine angenehme Eigenschaft von Kombinatoren ist es, dass man bei
der Arbeit damit in der Welt der Futures bleibt. So bildet
ein \emph{map} einen Future auf einen anderen ab. Es gibt keinen
Bruch innerhalb der Programmiersprache, das mentale Modell der
Futures bleibt intakt.

Sie ersparen es dem Programmierer zudem seinen Code mit verschachtelten
Callback-Methoden auszustatten. Diese machen Programme nicht nur
schwer lesbar, sie vermindern zudem die Sichtbarkeit von \emph{Futures}
die innerhalb eines geschachtelten Blocks erzeugt werden, so dass
außerhalb dieser Ebene nicht auf den Callback dieses \emph{Futures}
reagiert werden kann.

Ein Beispiel für \emph{Futures} mit Kombinatoren ist in \ref{lst:holiday}
gegeben. Ein Äquivalentes Programm mit verschachtelten Callbacks
ist in \ref{lst:holiday_nested} angegeben.

\paragraph{map} ist einer der grundlegenden Kombinatoren. Er bildet
einen \emph{Future} nach bestimmten Regeln auf einen anderen ab.

In \ref{lst:scala_map} ist ein einfaches Beispiel dafür gegeben.
In diesem Beispiel wird eine Gurke geerntet. Deren Eigenschaft ist eine
Krümmung (in Grad). Da sich nur einigermaßen gerade
Gurken gut verkaufen lassen, wird diese Future per \texttt{map}-Funktion
auf einen anderen Future abgebildet. Hier findet die Prüfung statt, ob
die Gurke verkehrsfähig ist oder entsorgt wird.

Falls sie nicht gerade genug ist, enthält der \texttt{harvestFuture}
eine Exception.

Möglicherweise schlägt schon der erste \emph{Future} fehl. Im gennanten
Beispiel könnte es passieren, dass keine Gurken mehr auf dem Feld sind.
In diesem Fall wird der erste \emph{Future} eine Exception beinhalten.
Die \texttt{map}-Funktion bildet in diesem Fall die Exception des
ersten \emph{Futures} auf den zweiten ab.

Im gezeigten Beispiel können daher zwei verschiedene Exceptions auftreten:
Im \texttt{cucumberFuture} sowie im \texttt{harvestFuture} besteht
die Möglichkeit eines Fehlers, der dazu führen würde dass das Ziel
(die Gruke zu ernten) nicht erreicht wird.

\lstinputlisting
    [caption={Pseudocode zum \emph{map}-Kombinator },
       label = lst:scala_map,
       captionpos=b]
 {../code/harvestluna/Harvest.pseudo}
 
\paragraph{filter} wendet ein Prädikat auf den Inhalt eines Futures
an. Ein Beispiel für die Verwendung dieses Kombinators könnte es sein,
dass ein \emph{Future} eine Nachricht enthält und die Nachricht nur
von Interesse ist wenn sie von einem bestimmten Absender stammt.

Wenn diese Bedinung erfüllt ist, so wird ein neuer Future genau
diese Nachricht enthalten, wenn sie nicht erfüllt ist wird er eine
\texttt{NoSuchElementException} enthalten.

% code beispiel
 
\paragraph{fallbackTo} ist ein Kombinator der zwei \emph{Futures}
verbindet. Dabei wird überprüft, ob der erste einen Wert (und damit
keine Exception) enthält. Wenn dies der Fall ist, wird dieser ausgewählt.
Enthält der erste Future eine Exception, dann wird der zweite überprüft.
Wenn dieser einen Wert enthält, wird er ausgewählt. Wenn er eine
Exception enthält, enthält auch der neu erstellte Future eine Exception.

\lstinputlisting
    [caption={Pseudocode zum \emph{fallbackTo}-Kombinator },
       label = lst:scala_fallbackTo,
       captionpos=b]
 {../code/lookingforsomething/Looking.pseudo}
 
In \ref{lst:scala_fallbackTo} ist ein einfaches Beispiel gegeben:

Eine Suchanfrage kann von verschiedenen Anbietern bearbeitet werden. 
Wenn ein Anbieter ausfällt, steht das Ergebnis eines anderen Anbieters 
zur Verfügung. Im ungünstigsten Fall stehen keine Anbieter zur Verfügung, 
dann ist es nicht möglich, ein Ergebnis anzuzeigen.

\paragraph{firstCompletedOf} wählt den \emph{Future} aus, der als
erstes beendet ist. Dies ist nützlich wenn es um Geschwindigkeit
geht. Wenn zum Beispiel ein Notfall passiert und über verschiedene
Kanäle ein Notruf abgesetzt wird, ist das einzig sinnvolle Kriterium
zur Auswahl, über welchen Kanal als erstes Hilfe zu erwarten ist.

\lstinputlisting
    [caption={Pseudocode zum \emph{firstCompletedOf}-Kombinator },
       label = lst:scala_firstCompletedOf,
       captionpos=b]
 {../code/accident/Accident.pseudo}
 
Listing \ref{lst:scala_firstCompletedOf} skizziert diesen
Anwendungsfall.

\paragraph{andThen}

\paragraph{For-Comprehension}
