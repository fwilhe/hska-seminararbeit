\section{Futures und Promises}

\subsection{Motivation}

Methodenaufrufe in üblichen Programmiersprachen sind blockierend. Das bedeutet,
dass das Hauptprogramm so lange blockiert wird, wie der Methodenaufruf läuft.
So wird in Listing XXX die Methode \texttt{tuEtwas()} eines Objektes aufgerufen.

\begin{lstlisting}
main() {
  objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

Führen wir das Schlüsselwort \texttt{nebenlaeufig} in unseren Pseudocode ein,
so können wir ausdrücken, dass die aufgerufene Methode nicht blockieren soll,
sondern dass im Hauptthread weitergearbeitet werden kann.

\begin{lstlisting}
main() {
  nebenlaeufig objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

Nun kann \texttt{tuEtwasAnderes()} \emph{nebenläufig} ausgeführt werden. Damit
ist es bei mehreren Prozessoren möglich, den Code parallel auszuführen.

Eine Analogie aus dem IT-Umfeld sind Unix-Shells. Wenn zum Beispiel ein
\texttt{find}-Befehl ausgeführt wird, so blockiert die Shell bis der Befehl
abgeschlossen ist. Durch Anhängen eines kaufmännischen Undzeichens ist es möglich,
den Befehl im Hintergrund laufen zu lassen, wodurch es möglich wird im selben
Terminal weiter zu arbeiten während der Befehl im Hintergrund (also nebenläufig)
läuft.

\subsection{Futures}

Im SIP-14 wird ein \emph{Future} wie folgt beschrieben:
\begin{quote}
Futures provide a nice way to reason about performing many operations in 
parallel– in an efficient and non-blocking way. The idea is simple, a Future 
is a sort of placeholder object that you can create for a result that doesn’t 
yet exist. Generally, the result of the Future is computed concurrently and can 
be later collected. Composing concurrent tasks in this way tends to result in 
faster, asynchronous, non-blocking parallel code.

A Future object either holds a result of a computation or an 
exception in the case that the computation failed.
\end{quote}

% non blocking



\subsection{Promises}

Ein \emph{Promise} hingegen wird im SIP-14 folgendermaßen beschrieben:
\begin{quote}
A promise can be thought of as a writeable, single-assignment container, which 
completes a future. That is, a promise can be used to successfully complete a 
future with a value (by \glqq completing\grqq{} the promise) using the \texttt{success} method. 
Conversely, a promise can also be used to complete a future with an exception, 
by failing the promise, using the \texttt{failure} method.
\end{quote}


\paragraph{Vergleich} von \emph{Futures} und \emph{Promises}.

%\begin{tabular}{p{}|p{}|p{}}
%foo & bar & baz \\
%foo & bar & baz
%\end{tabular}
