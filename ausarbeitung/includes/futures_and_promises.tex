\section{Futures und Promises}

\subsection{Motivation}

Methodenaufrufe in üblichen Programmiersprachen sind blockierend. Das bedeutet,
dass das Hauptprogramm so lange blockiert wird, wie der Methodenaufruf läuft.
So wird in Listing \ref{lst:codeBlocking} die Methode \texttt{tuEtwas()} eines Objektes aufgerufen.

\begin{lstlisting}[caption={Blockierender Methodenaufruf},label={lst:codeBlocking},captionpos=b]
main() {
  objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

Führen wir das Schlüsselwort \texttt{nebenlaeufig} in unseren Pseudocode ein,
so können wir ausdrücken, dass die aufgerufene Methode nicht blockieren soll,
sondern dass im Hauptthread weitergearbeitet werden kann.

\begin{lstlisting}[caption={Nebenläufiger Methodenaufruf},label={lst:codeConcurrent},captionpos=b]
main() {
  nebenlaeufig objekt.tuEtwas()
  tuEtwasAnderes()
}
\end{lstlisting}

Nun kann \texttt{tuEtwasAnderes()} \emph{nebenläufig} ausgeführt werden. Damit
ist es bei mehreren Prozessoren möglich, den Code parallel auszuführen.

Eine Analogie aus dem IT-Umfeld sind Unix-Shells. Wenn zum Beispiel ein
\texttt{find}-Befehl ausgeführt wird, so blockiert die Shell bis der Befehl
abgeschlossen ist. Durch Anhängen eines kaufmännischen Undzeichens ist es möglich,
den Befehl im Hintergrund laufen zu lassen, wodurch es möglich wird im selben
Terminal weiter zu arbeiten während der Befehl im Hintergrund (also nebenläufig)
läuft.

\subsection{Futures}

Im SIP-14 wird ein \emph{Future} wie folgt beschrieben:
\begin{quote}
Futures provide a nice way to reason about performing many operations in 
parallel– in an efficient and non-blocking way. The idea is simple, a Future 
is a sort of placeholder object that you can create for a result that doesn’t 
yet exist. Generally, the result of the Future is computed concurrently and can 
be later collected. Composing concurrent tasks in this way tends to result in 
faster, asynchronous, non-blocking parallel code.

A Future object either holds a result of a computation or an 
exception in the case that the computation failed.
\end{quote}

Das erklärte Ziel ist es, einen angenehmen Weg zu schaffen um nicht
blockierend (\glqq non-blocking\grqq{}) zu programmieren.

Alles was innerhalb eines \emph{Futures} passiert läuft nicht im
Hauptthread.

\paragraph{Einfaches Beispiel in Pseudocode}

\lstinputlisting
    [caption={Pseudocode zum Minimalbeispiel eines Futures },
       label = lst:scala_mini_future,
       captionpos=b]
 {../code/minimal/future/Future.pseudo}
 
In Listing \ref{lst:scala_mini_future} ist der Umgang mit einem \emph{Future}
skizziert. Sie sind generische Typen, es ist also Möglich \emph{Futures}
zu verwenden die beliebige Typen beinhalten. Der Code des \emph{Futures}
wird innerhalb des \texttt{future \{ ... \}}-Blocks definiert. Der
Rückgabewert muss dem Typen entsprechen, den der \emph{Future} zurückgibt.

\subsection{Promises}

Ein \emph{Promise} hingegen wird im SIP-14 folgendermaßen beschrieben:
\begin{quote}
A promise can be thought of as a writeable, single-assignment container, which 
completes a future. That is, a promise can be used to successfully complete a 
future with a value (by \glqq completing\grqq{} the promise) using the \texttt{success} method. 
Conversely, a promise can also be used to complete a future with an exception, 
by failing the promise, using the \texttt{failure} method.
\end{quote}

Das Konzept \emph{Promise} baut auf den \emph{Futures} auf. Es bietet
einmaligen Schreibzugriff auf ein Objekt, das zum gegebenen Zeitpunkt
noch nicht beschrieben werden kann, zum Beispiel weil dieser Wert
noch nicht berechnet worden ist.

\paragraph{Einfaches Beispiel in Pseudocode}

\lstinputlisting
    [caption={Pseudocode zum Minimalbeispiel eines Promises },
       label = lst:scala_mini_promise,
       captionpos=b]
 {../code/minimal/promise/Promise.pseudo}
 
Im Beispiel in Listing \ref{lst:scala_mini_promise} ist ein \emph{Promise} zu sehen.
Jedes \emph{Promise} beinhaltet ein \emph{Future}. Im Programm kann
nun so lange gerechnet werden, bis der Wert mit dem das \emph{Promise}
vervollständigt werden kann verfügbar ist. Im Beispiel ist dieser
Wert der Einfachheit halber hart codiert, in der Praxis wird er das
nicht sein.

\paragraph{Vergleich} von \emph{Futures} und \emph{Promises}.

\begin{table}[h]
\begin{tabular}{lllll}
 & \textbf{Eigenschaft} & \textbf{Future} & \textbf{Promise} &  \\
 & Lesbar & Ja & Nein &  \\
 & Schreibbar & Nein & Ja &  \\
 & Beinhaltet anderen & Nein & Ja &  \\
 &  &  &  &  \\
 &  &  &  &  \\
 &  &  &  & 
\end{tabular}
\end{table}

\subsection{Kombinatoren}

Ein Weg um \emph{Futures} und \emph{Promises} noch mächtiger
zu machen besteht darin, diese zu kombinieren. Dazu gibt es verschiedene
Möglichkeiten.

% carcare for yield
\paragraph{For Comprehension} ist ein grundlegender Bestandteil
der Sprache \emph{Scala}, den es vor \emph{Futures} und \emph{Promises}
gab. Dieser erinnert, auch aufgrund des Schlüsselworts \emph{for}
an Schleifen, wie sie aus imperativen und objektorientierten
Programmiersprachen bekannt sind.

\begin{lstlisting}[caption={For Comprehension},label={lst:forComprehension},captionpos=b]
val seq = Seq(1, 2, 3, 4, 5)
for (i <- seq if i % 2 == 0) yield i
\end{lstlisting}

In Listing \ref{lst:forComprehension} ist ein minimales Beispiel für
eine \emph{For Comprehension} gegeben.

Durch den \texttt{<-}-Operator wird nach und nach jedes Element
der Sequenz an die Variable \texttt{i} gebunden.

In \texttt{yield} kann auf das Ergebnis reagiert werden.

\paragraph{Beispiel} für die Kombination von \emph{Futures} mittels
einer \emph{For Comprehension}

\lstinputlisting
    [caption={Pseudocode zur \emph{For Comprehension} },
       label = lst:scala_for_comprehension,
       captionpos=b]
 {../code/carcare/Carcare.pseudo}
 
In diesem Beispiel wird an einem PKW gearbeitet. Es gibt zwei
Aufgaben, die erledigt werden müssen: Ein Reifen muss gewechselt werden
(dies unterteilt sich in die voneinander abhängigen Teilaufgaben
\emph{Neuen Reifen besorgen} und \emph{Neuen Reifen montieren}) und
das Fahrzeug muss gewaschen werden. Bevor der neue Reifen also montiert
werden kann muss gewartet werden bis er verfügbar ist. Diese Zeit
kann genutzt werden um einen Teil zu waschen.

Während die \texttt{cleanCar()}-Methode im Hauptthread arbeitet
blockiert die andere Aufgabe so lange, bis die erste Teilaufgabe
erfüllt ist. Danach kann der neue Reifen montiert werden und
eine Erfolgsmeldung ausgegeben werden.

% andThen, foldLeft, flatMap, foreach and filter
\paragraph{andThen, foldLeft, flatMap, foreach und filter}
