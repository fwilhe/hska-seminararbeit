%
% seminararbeit_florian_wilhelm_36873 Florian Wilhelm
% Erstellt am 19.03.2014
%
% Bauen mit dem beiliegenden Makefile

\documentclass[11pt,a4paper,titlepage,ngerman]{scrartcl}

% Deutsch mit neuer Rechtschreibung
\usepackage[ngerman]{babel}

% Umlaute direkt eingeben http://www.jr-x.de/publikationen/latex/tipps/besonderheiten.html
% Hatte hier ursprünglich "latin1" als Option, das ging aber nicht. Hängt wohl von der Codierung des Dokumentes ab.
\usepackage[utf8]{inputenc} 

% Einbinden von Grafiken
\usepackage{graphicx}

\usepackage{listings}

% Setzen der Eigenschaften der erzeugten PDF-Datei
\usepackage[pdftex,
    pdfauthor={Florian Wilhelm},
    pdfsubject={Seminararbeit Florian Wilhelm MatrNr 36873},
    pdftitle={Futures and Promises in Scala},    
    pdfproducer={Latex with hyperref},
    pdfcreator={pdflatex}]{hyperref}

% Glossar-Paket laden und Glossar erzeugen
% Hierfür sind mehrere Übersetzungsvorgänge nötig. Dafür gibt es ein Build-Target im Makefile.
\usepackage[toc]{glossaries}
\makeglossaries

%
% Glossar
%
\newglossaryentry{sip}{name={Scala Improvement Process}, description={ist eine Platform auf der Verbesserungen der Programmiersprache Scala vorgestellt werden. Es ist notwendig ein SIP-Dokument einzureichen, wenn man die Sprache oder die Standardbibliothek erweitern möchte. Die Plattform ist unter \url{http://docs.scala-lang.org/sips/} zu erreichen}}
\newglossaryentry{lazy}{name=Lazy evaluation, description={bedeutet, dass eine Berechnung erst dann ausgeführt wird, wenn sie benötigt wird}}
\newglossaryentry{nebenlaeufig}{name=Nebenläufigkeit, description={ bedeutet, dass zwei oder mehr Prozesse \emph{unabhängig} bearbeitet werden können. Es spielt keine Rolle, in welcher Reihenfolge oder ob sie gar gleichzeitig bearbeitet werden. Dabei ist zu beachten, dass Gleichzeitigkeit kein Kriterium für Nebenläufigkeit ist. Wenn Prozesse gleichzeitig ablaufen, so laufen sie \emph{parallel}, was ein Spezialfall der Nebenläufigkeit ist}}
\newglossaryentry{lambda}{name=Lambda-Ausdrücke, description={ beschreiben \emph{anonyme Funktionen}, also solche Funktionen die nicht explizit mit einem Namen deklariert werden, sondern zum Beispiel als Argumente übergeben werden können. Sie sind eine der großen Neuerungen in der Programmiersprache \emph{Java 8}}} 
\newglossaryentry{akka}{name=Akka, description={ist eine Programmbibliothek, die es erlaubt nebenläufige, verteilte und fehlertolerante Applikationen auf Basis der Java Virtual Machine zu erstellen. Sie ist erhältlich für Scala und für Java, und stellt seit Scala Version 2.10 die Standardimplementierung für Aktoren. Akka ist unter \url{http://akka.io/} als freie Software erhältlich}}
\newglossaryentry{erlang}{name=Erlang, description={ist eine funktionale Programmiersprache, die ursprünglich von Ericsson entwickelt wurde. Der Name kann als Kurzform für \emph{Ericsson language} gelesen werden. Sie wird überwiegend im Telekommunikationsbereich eingesetzt. Sie ist unter \url{http://www.erlang.org/} als freie Software verfügbar}}
%\newglossaryentry{yyy}{name=xxx, description={}} 
%\newglossaryentry{yyy}{name=xxx, description={}} 
%\newglossaryentry{yyy}{name=xxx, description={}} 
%\newglossaryentry{yyy}{name=xxx, description={}} 
%\newglossaryentry{yyy}{name=xxx, description={}} 
% Template: \newglossaryentry{yyy}{name=xxx, description={}} 

%
% Glossar Ende
%

%Römische Zahlen
% http://www.mrunix.de/forums/showthread.php?t=44246
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{.}}}

\begin{document}

% Zeilenumbrüche in Code-listings
\lstset{breaklines=true}

\titlehead{
	\includegraphics[width=0.9\linewidth]{pic/500px-Hska_logo.png}
}
\title{Seminararbeit}
\subtitle{Futures and Promises in Scala}
\author{Florian Wilhelm \\
		Matrikelnummer: 36873\\
		Sommersemester 2014}
\publishers{
    \textbf{Betreuer:} Prof. Dr. Martin Sulzmann
}
\maketitle

\tableofcontents
\newpage

\section{Einleitung}
\subsection{Vorwort}

Ziel dieser Arbeit ist es, das Konstrukt der Futures und Promises zu untersuchen.
Dabei wird die Implementierung in der Programmiersprache Scala herangezogen.

Futures und Promises gehen zurück auf die Sprachen 
\emph{Mozart Programming System}, \emph{Alice} und \emph{MultiLisp}. Sie sind
heute in einer Vielzahl von Sprachen verfügbar, oftmals durch Drittanbieter
Bibliotheken.

%TODO http://www.ps.uni-saarland.de/alice/manual/futures.html
%TODO http://mozart.github.io/publications/abstracts/oz-futures.html

Der vollständige Code dieser Seminararbeit ist unter \cite{code} verfügbar.

\subsubsection{Scala}

Mit Scala habe ich mich bereits in meiner Projektarbeit \cite{Wilhelm13} befasst, darum soll es 
in dieser Arbeit bei einer kurzen Vorstellung der wichtigsten Merkmale dieser
Sprache bleiben.

Scala ist eine objektorientierte und funktionale Sprache für die JVM. Sie
leistet Pionierarbeit für das Java-Ökosystem, in dem sie Features implementiert
die von Java übernommen werden. Als Beispiel sei auf die \gls{lambda} in
Java 8 verwiesen.

Ein weiteres Sprachmerkmal von Scala sind \emph{Traits}, was mit 
\glqq Charakterzug\grqq{} übersetzt werden kann. Dabei handelt es sich im
Wesentlichen um Interfaces, in denen Methoden implementiert werden können.
Klassen können sich mehrere dieser \glqq Charakterzüge\grqq{} aneignen.
So ist es möglich, ein Verhalten zu erzeugen das dem von Sprachen ähnelt, die
Mehrfachvererbung unterstützen, ohne die zum Beispiel von \emph{C++} bekannten
Probleme zu erhalten.

Java 8 zieht auch hier nach und bietet mit \emph{default}-Methoden in Interfaces
ähnliches an.

Die Sprache findet auch in der Industrie Anwendung, so wird sie unter anderem von Twitter,
Sony und Foursquare eingesetzt (vgl. \cite{scalaInEnterprise}).

Ähnlich wie zum Beispiel \emph{\gls{erlang}} bietet sich Scala vor allem dort an,
wo mit vielen nicht vorhersehbaren Ereignissen umzugehen ist.

Ein starker Fokus liegt darauf, \gls{nebenlaeufig} in der Multicore-Ära
zu ermöglichen. Erreicht wird dies durch Sprachkonstrukte wie \emph{Actors},
\emph{Futures} und \emph{Promises}.


\section{Futures und Promises}

\subsection{Historie}

Die erste Erwähnung von Futures geht zurück auf das Jahr 1977 
(Siehe \cite{Baker:1977:IGC:872734.806932}).

Futures werden beschrieben als Sprachkonstrukte, die asynchron laufen. Sie 
könnten zum Beispiel in der Form 
\begin{lstlisting}
(ENTWEDER <ausdruck_1> <ausdruck_2> .. <ausdruck_n>)
\end{lstlisting}
angegeben werden. Diese Notation sollte alle n Ausdrücke nebenläufig ausführen, 
die Rückgabe sollte die des ersten Ausdrucks sein, der ein Ergebnis zurückliefert.
Dabei war es die Idee, jeden Ausdruck auf einem eigenen Prozessor auszuführen, 
wenigstens aber alle Ausdrücke auf mehrere Prozessoren zu verteilen. Hier ist in 
einem 1977 veröffentlichten Papier bereits eine zentrale Problemstellung der 
heutigen Zeit beschrieben: Die effiziente Softwareentwicklung in der Multicore-Ära.

Der theoretische Anspruch in diesem Dokument wird im Fazit deutlich, in dem klar 
gesagt wird, dass keine Hardware verfügbar sei auf der diese Ideen umgesetzt 
werden könnten.

\subsubsection{Implementierung in Mozart \cite{futures:98}}

TODO

\subsubsection{Implementierung in Alice \cite{aliceFuture}}

Im Handbuch der Programmiersprache \emph{Alice} werden Futures folgendermaßen
beschrieben:
\begin{quote}
Ein \emph{future} ist ein Platzhalter für das unbestimmte Resultat einer
(nebenläufigen) Berechnung. Wenn die Berechnung ein Ergebnis liefert, dann
wird der Wert der \emph{future} im globalen Kontext durch dieses ersetzt.
Dieser Wert kann selbst ein \emph{future} sein.
\end{quote} (Sinngemäß aus dem Englischen übersetzt)

\emph{Futures} in \emph{Alice} können mittels \gls{lazy} berechnet werden. 
Dies muss durch die Verwendung des \emph{lazy}-Schlüsselwortes explizit angefordert werden.

In diesem Handbuch werden auch \emph{Promises} erwähnt, wobei diese eine Variante
der \emph{Futures} darstellen. In \emph{Alice} wird mit jedem \emph{Promise}
ein neuer \emph{Future} erzeugt.

Basis für Implementierung in Scala: \cite{Lea:2000:JFF:337449.337465}

TODO

\subsection{Implementierung in scala.concurrent}

Futures und Promises sind für Scala beschrieben in dem \gls{sip}-Dokument SIP-14 
(vgl. \cite{sip14}).

Es gab bereits seit längerem verschiedene Implementierungen dieser Sprachmittel,
unter anderem im \gls{akka}-Framework, in Skalaz, in den Twitter-Util-Klassen so wie
in java.util.concurrent (vgl. \cite{futuresTry}).

Um der Fragmentierung im Umfeld der Programmiersprache entgegenzuwirken und
diese Techniken für alle Scala-Entwickler zugänglich zu machen, wurde auf Basis
des \gls{sip}-Dokuments SIP-14 eine Implementierung im scala.concurrent-Package
vorgenommen.

Im SIP-14 wird ein Future wie folgt beschrieben:
\begin{quote}
Futures provide a nice way to reason about performing many operations in 
parallel– in an efficient and non-blocking way. The idea is simple, a Future 
is a sort of placeholder object that you can create for a result that doesn’t 
yet exist. Generally, the result of the Future is computed concurrently and can 
be later collected. Composing concurrent tasks in this way tends to result in 
faster, asynchronous, non-blocking parallel code.

A Future object either holds a result of a computation or an 
exception in the case that the computation failed.
\end{quote}

Es ist also hervorzuheben, dass Futures nicht blockieren, im Hauptprogramm
kann sinnvoll gearbeitet werden während der Wert des Futures berechnet wird.
Somit wird es vergleichsweise einfach, Code zu schreiben der auf mehreren
Prozessoren gleichzeitig ausgeführt werden kann.

Ein Future in Scala ist ein nur-lese-Wert.

Ein Promise hingegen wird im SIP-14 folgendermaßen beschrieben:
\begin{quote}
A promise can be thought of as a writeable, single-assignment container, which 
completes a future. That is, a promise can be used to successfully complete a 
future with a value (by \glqq completing\grqq{} the promise) using the \texttt{success} method. 
Conversely, a promise can also be used to complete a future with an exception, 
by failing the promise, using the \texttt{failure} method.
\end{quote}

Ein Promise ist also ein \glqq Container\grqq{} in den genau einmal geschrieben
werden kann. Entweder den Wert den der zugehörige Future errechnet hat
(womit sinnbildlich das Versprechen eingelöst wird) oder mit einer Exception
(womit das Versprechen gebrochen wird).

Ein Promise beinhaltet immer einen Future. Ein Future kann aber ohne Promise
existieren.

Da es sich bei Scala um freie Software handelt, ist diese Implementierung
unter \cite{scalaConcurrentCode} verfügbar.

\section{Einfache Beispiele für Futures und Promises}

Die Grundlegende Syntax von Futures und Promises soll hier anhand von minimalen
Beispielen vorgestellt werden. Diese sind so konzipiert dass sie nichts
tun, aber direkt lauffähig sind. Um die Beispiele, die unter \cite{code}
verfügbar sind nachzuvollziehen reicht es im richtigen Verzeichnis 
\texttt{scalac *.scala \&\& scala de.hska.wifl1011.seminararbeit.Main} auszuführen.
Alternativ dazu kann das beiliegende Makefile verwendet werden, welches genau
diese Befehle ausführt.

\subsection{Future}

In Listing \ref{lst:scala_mini_future} ist ein lauffähiges Beispiel für einen 
Future abgebildet. Im Beispiel tut dieser nichts weiteres als einen konstanten
Wert zurückzuliefern. Innerhalb dieses Codeblocks kann eine beliebige Berechnung
ausgeführt werden, die dann nebenläufig zum Main-Thread läuft. Sobald der Future
erfolgreich beendet ist wir die \texttt{onSuccess}-Methode aufgerufen, in der
das Ergebnis verarbeitet werden kann. \emph{Erfolgreich} bedeutet in diesem
Fall dass der Future einen Wert zurückgibt. Die andere Möglichkeit ist, dass
er eine Exception enthält. Auf diesen Fall könnte man in der \texttt{onFailure}-Methode
reagieren. Es ist ebenso möglich beide Fälle in einer allgemeineren
\texttt{onComplete}-Methode zu behandeln.

\lstinputlisting
    [caption={Code zum Minimalbeispiel eines Futures },
       label = lst:scala_mini_future,
       captionpos=b]
 {../code/minimal/future/Main.scala}

\subsection{Promise}

In Listing \ref{lst:scala_mini_promise} ist ein minimales Beispiel für den
Einsatz eines Promises dargestellt. Es wird so deklariert, dass es einen
Integer-Wert erwaret. Erfüllen kann man das Promise via der \texttt{success}-Methode.
Wenn diese aufgerufen wird, dann wird der zum Promise zugehörige Future ausgelöst
und in seiner \texttt{onSuccess}-Methode kann mit dem Wert weitergearbeitet werden.

\lstinputlisting
    [caption={Code zum Minimalbeispiel eines Promises },
       label = lst:scala_mini_promise,
       captionpos=b]
 {../code/minimal/promise/Main.scala}

\section{Anwendungsfälle für Futures und Promises}

Anhand von mehreren Anwendungsfällen soll der Nutzen von Futures und Promises
verdeutlicht werden. 

\subsection{Ein Urlaub in der Südsee}

Nehmen wir an, die Urlaubsplanung steht vor der Tür. Es ist natürlich wichtig
zu wissen, wie der Wechselkurs der Währung des Landes steht, in dem wir uns
erholen möchten. Wenn der Wechselkurs allzu nachteilhaft für uns ist,
verzichten wir lieber auf einen Urlaub zu diesem Zeitpunkt und erkundigen
uns im nächsten Jahr noch einmal.

Im Beispiel verwenden wir zwei Futures: Einen um den Wechelkurs zu bestimmen
und einen um den Flug zu buchen. In beiden Futures wird mittels der Zufallsfunktion
die Möglichkeit simuliert, dass die Anfrage fehl schlägt, zum Beispiel weil
die Onlineservices nicht verfügbar sind. Solche Fehlerzustände sind ein elementarer
Bestandteil von Futures in Scala.

\lstinputlisting
    [caption={Code zum Anwendungsfall \glqq Ein Urlaub in der Südsee\grqq{} },
       label = lst:scala_holiday,
       captionpos=b]
 {../code/holiday/Main.scala}
 

\subsection{Ein Tag auf der Baustelle}

In diesem Beispiel beobachten wir die Arbeit auf einer Baustelle. Wir sehen
den Meister mit seinem Lehrling. Als die beiden mit der Arbeit beginnen möchten
fällt ihnen auf, dass sie den Werkzeugkasten im Auto vergessen haben. Also
geht der Lehrling los um diesen zu holen.

Da Futures nicht blockierend sind, kann der Meister die Zeit nutzen um bereits
ein paar Messungen vorzunehmen. Sobald der Lehrling mit dem Werkzeugkasten
zurückkommt unterbricht er diese Arbeit um das richtige Werkzeug zu nehmen.
Doch auch in diesem Fall gibt es die Möglichkeit, dass das richtige Werkzeug
für die Aufgabe nicht im Werkzeugkasten ist.

Der Lehrling ist unterdessen schon dabei die Baustelle zu säubern, schließlich
haben sie keine Zeit zu verlieren.

Mit der Zeile \texttt{myPromise.success(toolbox)} wird das Versprechen,
den Werkzeugkasten zu holen, eingelöst.

In diesem Beispiel ist schön zu sehen, dass Promises wirklich nur einmal
beschrieben werden können. Würden wir die auskommentierte Codezeile
\texttt{myPromise.success(23)} einkommentieren, so erhielten wir eine
Exception.

\lstinputlisting
    [caption={Code zum Anwendungsfall \glqq Ein Tag auf der Baustelle\grqq{} },
       label = lst:scala_constructionsite,
       captionpos=b]
 {../code/constructionsite/Main.scala}

\subsection{Ein Unfall}

Wir brechen nun auf zu einem schönen Ausflug bei gutem Wetter. Alles sieht
nach einem unvergesslichen Tag aus. Doch plötzlich stört ein schwerer Unfall
die Idylle. Nun haben wir keine Zeit zu verlieren, wir setzen alle Hebel in
Bewegung um schnell einen Arzt zu rufen. Dabei ist uns egal welcher
Weg zum Erfolg führt und wir nehmen in Kauf, dass sich mehrere Notärzte gleichzeitig
auf den Weg machen.

Auch ein solches Verhalten kann mittels Futures simuliert werden.

\lstinputlisting
    [caption={Code zum Anwendungsfall \glqq Ein Unfall\grqq{} },
       label = lst:scala_accident,
       captionpos=b]
 {../code/accident/Main.scala}
 
Ein möglicher Einsatz für diesen Anwendungsfall könnte es sein, wenn wir von
einem Webdienst eine Anfrage beantwortet haben möchten. So gibt es zum Beispiel
verschiedene Anbieter von Kartenmaterial im Internet. Wenn wir nun eine Adresse
zu einer Geokoordinate umgerechnet haben möchten, so könnten wir alle verfügbaren
Dienste anfragen, jeden in einem eigenen Future, und auf den reagieren der uns
als erstes eine Antwort bereit stellt. Gerade unterwegs mit meist relativ schlechter
Internetverbindung sind Wartezeiten nervig und zu guter Gebrauchstaulichkeit der
Software gehört zweifelsohne dass sie möglichst schnell eine Antwort liefert.

\subsection{...}

\newpage
\section{Zusammenfassung und Fazit}

Die vorliegende Seminararbeit führt am Beispiel einiger Anwendungsfälle vor,
dass Futures und Promises geeignete Abstraktionsmittel sind um nebenläufig
zu programmieren. Des weiteren wird gezeigt, dass die Implementierung dieser
Sprachmittel im \texttt{scala.concurrent}-Package es leicht macht, mit den
Mitteln zu experimentieren.

Dabei sind diese Ideen, das zeigt \cite{Baker:1977:IGC:872734.806932}, gar nicht
so jung wie man vielleicht denken möchte. Umso unverständlicher ist es, dass
sie noch nicht zum Handwerkszeug eines jeden Softwareentwicklers gehören.

Es wird (vor Allem im Zusammenhang mit Aktoren) deutlich, dass die Entwickler
der Sprache \emph{Scala} und ihrer Standardbibliothek großen Wert darauf legen,
nebenläufige Programmierung einfach und zugänglich zu machen. Gerade im Hinblick
auf die immer größere Verbreitung von Mehrkernsystemen kann sich heute kaum ein
Entwickler vor nebenläufigen Problemstellungen drücken.

\newpage

\section{Quellen- und Literaturverzeichnis}

\bibliographystyle{plain}
\bibliography{seminararbeit_florian_wilhelm_36873}

\section{Abbildungs- und Tabellenverzeichnis}

\renewcommand{\listfigurename}{Verzeichnis der Abbildungen}
\listoffigures

\newpage

\printglossary

\end{document}
