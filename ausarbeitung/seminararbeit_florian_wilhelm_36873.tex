%
% seminararbeit_florian_wilhelm_36873 Florian Wilhelm
% Erstellt am 19.03.2014
%
% Bauen mit dem beiliegenden Makefile

\documentclass[11pt,a4paper,titlepage,ngerman]{scrartcl}

% Deutsch mit neuer Rechtschreibung
\usepackage[ngerman]{babel}

% Umlaute direkt eingeben http://www.jr-x.de/publikationen/latex/tipps/besonderheiten.html
% Hatte hier ursprünglich "latin1" als Option, das ging aber nicht. Hängt wohl von der Codierung des Dokumentes ab.
\usepackage[utf8]{inputenc} 

% Einbinden von Grafiken
\usepackage{graphicx}

\usepackage{listings}

% Setzen der Eigenschaften der erzeugten PDF-Datei
\usepackage[pdftex,
    pdfauthor={Florian Wilhelm},
    pdfsubject={Seminararbeit Florian Wilhelm MatrNr 36873},
    pdftitle={Futures and Promises in Scala},    
    pdfproducer={Latex with hyperref},
    pdfcreator={pdflatex}]{hyperref}

% Glossar-Paket laden und Glossar erzeugen
% Hierfür sind mehrere Übersetzungsvorgänge nötig. Dafür gibt es ein Build-Target im Makefile.
\usepackage[toc]{glossaries}
\makeglossaries

%
% Glossar
%
\newglossaryentry{sip}{name={Scala Improvement Process}, description={ist eine Platform auf der Verbesserungen der Programmiersprache Scala vorgestellt werden. Es ist notwendig ein SIP-Dokument einzureichen, wenn man die Sprache oder die Standardbibliothek erweitern möchte. Die Plattform ist unter \url{http://docs.scala-lang.org/sips/} zu erreichen}}
\newglossaryentry{lazy}{name=Lazy evaluation, description={bedeutet, dass eine Berechnung erst dann ausgeführt wird, wenn sie benötigt wird}}
% Template: \newglossaryentry{yyy}{name=xxx, description={}} 

%
% Glossar Ende
%

%Römische Zahlen
% http://www.mrunix.de/forums/showthread.php?t=44246
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{.}}}

\begin{document}

% Zeilenumbrüche in Code-listings
\lstset{breaklines=true}

\titlehead{
	\includegraphics[width=0.9\linewidth]{pic/500px-Hska_logo.png}
}
\title{Seminararbeit}
\subtitle{Futures and Promises in Scala}
\author{Florian Wilhelm \\
		Matrikelnummer: 36873\\
		Sommersemester 2014}
\publishers{
    \textbf{Betreuer:} Prof. Dr. Martin Sulzmann
}
\maketitle

\tableofcontents
\newpage

\section{Einleitung}
\subsection{Vorwort}

Ziel dieser Arbeit ist es, das Konstrukt der Futures und Promises zu untersuchen.
Dabei wird die Implementierung in der Programmiersprache Scala herangezogen.

Futures und Promises gehen zurück auf die Sprachen 
\emph{Mozart Programming System}, \emph{Alice} und \emph{MultiLisp}. Sie sind
heute in einer Vielzahl von Sprachen verfügbar, oftmals durch drittanbieter
Bibliotheken.

%TODO http://www.ps.uni-saarland.de/alice/manual/futures.html
%TODO http://mozart.github.io/publications/abstracts/oz-futures.html

Der vollständige Code dieser Seminararbeit ist unter \cite{code} verfügbar.

\subsubsection{Scala}

Mit Scala habe ich mich bereits in meiner Projektarbeit \cite{Wilhelm13} befasst, darum soll es 
in dieser Arbeit bei einer kurzen Vorstellung der wichtigsten Merkmale dieser
Sprache bleiben.

Scala ist eine objektorientierte und funktionale Sprache für die JVM. Sie
leistet Pionierarbeit für das Java-Ökosystem, in dem sie Features implementiert
die von Java übernommen werden. Als Beispiel sei auf die Lambda-Ausdrücke in
Java 8 verwiesen.

Ein weiteres Sprachmerkmal von Scala sind \emph{Traits}, was mit 
\glqq Charakterzug\grqq übersetzt werden kann. Dabei handelt es sich im
Wesentlichen um Interfaces, in denen Methoden implementiert werden können.
Klassen können sich mehrere dieser \glqq Charakterzüge\grqq aneignen.
So ist es möglich ein Verhalten zu erzeugen das dem von Sprachen ähnelt die
Merfachvererbung unterstützen ohne die zum Beispiel von \emph{C++} bekannten
Probleme zu erhalten.

Java 8 zieht auch hier nach und bietet mit \emph{default}-Methoden in Interfaces
ähnliches an.

Die Sprache findet auch in der Industrie Anwendung, so wird sie unter Anderem von Twitter,
Sony und Foursquare eingesetzt (vgl. \cite{scalaInEnterprise}).

Ähnlich wie zum Beispiel \emph{Erlang} bietet sich Scala vor allem dort an,
wo mit vielen nicht vorhersehbaren Ereignissen umzugehen ist.

Ein starker Fokus liegt darauf, nebenläufige Programmierung in der Multicore-Ära
zu ermöglichen. Erreicht wird dies durch Sprachkonstrukte wie \emph{Actors},
\emph{Futures} und \emph{Promises}.


\section{Futures und Promises}

\subsection{Historie}

Die erste Erwähnung von Futures geht zurück auf das Jahr 1977 
(Siehe \cite{Baker:1977:IGC:872734.806932}).

Futures werden beschrieben als Sprachkonstrukte, die asynchron laufen. Sie 
könnten zum Beispiel in der Form 
\begin{lstlisting}
(ENTWEDER <ausdruck_1> <ausdruck_2> .. <ausdruck_n>)
\end{lstlisting}
angegeben werden. Diese Notation sollte alle n Ausdrücke nebenläufig ausführen, 
die Rückgabe sollte die des ersten Ausdrucks sein, der ein Ergebnis zurückliefert.
Dabei war es die Idee, jeden Ausdruck auf einem eigenen Prozessor auszuführen, 
wenigstens aber alle Ausdrücke auf mehrere Prozessoren zu verteilen. Hier ist in 
einem 1977 veröffentlichten Papier bereits eine zentrale Problemstellung der 
heutigen Zeit beschrieben: Die effiziente Softwareentwicklung in der Multicore-Ära.

Der theoretische Anspruch in diesem Dokument wird im Fazit deutlich, in dem klar 
gesagt wird, dass keine Hardware verfügbar sei auf der diese Ideen umgesetzt 
werden könnten.

Implementierung in Mozart \cite{futures:98}

Implementierung in Alice 
\cite{aliceFuture}

Im Handbuch der Programmiersprache \emph{Alice} werden Futures folgendermaßen
beschrieben:
\begin{quote}
Ein \emph{future} ist ein Platzhalter für das unbestimmte Resultat einer
(nebenläufigen) Berechnung. Wenn die Berechnung ein Ergebnis liefert, dann
wird der Wert der \emph{future} im globalen Kontext durch dieses ersetzt.
Dieser Wert kann selbst ein \emph{future} sein.
\end{quote} (Sinngemäß aus dem Englischen übersetzt)

\emph{Futures} in \emph{Alice} können mittels \gls{lazy} berechnet werden. 
Dies muss durch die Verwendung des \emph{lazy}-Schlüsselwortes explizit angefordert werden.

In diesem Handbuch werden auch \emph{Promises} erwähnt, wobei diese eine Variante
der \emph{Futures} darstellen. In \emph{Alice} wird mit jedem \emph{Promise}
ein neuer \emph{Future} erzeugt.

Basis für Implementierung in Scala: \cite{Lea:2000:JFF:337449.337465}

\subsection{Implementierung in scala.concurrent}

Futures und Promises sind für Scala beschrieben in dem \gls{sip}-Dokument SIP-14 
(vgl. \cite{sip14}).

Die Imlementierung in Scala kann unter \cite{scalaConcurrentCode} abgerufen werden.
%TODO https://github.com/scala/scala/blob/master/src/library/scala/concurrent/Future.scala
%TODO https://github.com/scala/scala/blob/master/src/library/scala/concurrent/Promise.scala

\section{Anwendungsfälle für Futures und Promises}

Anhand von mehreren Anwendungsfällen soll der Nutzen von Futures und Promises
verdeutlicht werden. 

\subsection{Ein Urlaub in der Südsee}

Nehmen wir an, die Urlaubsplanung steht vor der Tür. Es ist natürlich wichtig
zu wissen, wie der Wechselkurs der Währung des Landes steht, in dem wir uns
erholen möchten. Wenn der Wechselkurz allzu nachteilhaft für uns steht,
dann verzichten wir lieber auf einen Urlaub zu diesem Zeitpunkt und erkundigen
uns im nächsten Jahr nocheinmal.

Im Beispiel verwenden wir zwei Futures: Einen um den Wechelkurs zu bestimmen,
und einen um den Flug zu buchen. In beiden Futures wird mittels der Zufallsfunktion
die Möglichkeit simuliert, dass die Anfrage fehl schlägt, zum Beispiel weil
die Onlineservices nicht verfügbar sind. Solche Fehlerzustände sind ein elementarer
Bestandteil von Futures in Scala.

\lstinputlisting
    [caption={Code zum Anwendungsfall \glqq Ein Urlaub in der Südsee\grqq },
       label = lst:scala_holiday,
       captionpos=b]
 {../code/holiday/Main.scala}
 

\subsection{...}
\subsection{...}
\subsection{...}

\newpage
\section{Zusammenfassung und Fazit}

Lorem.

\newpage

\section{Quellen- und Literaturverzeichnis}

\bibliographystyle{plain}
\bibliography{seminararbeit_florian_wilhelm_36873}

\section{Abbildungs- und Tabellenverzeichnis}

\renewcommand{\listfigurename}{Verzeichnis der Abbildungen}
\listoffigures

\newpage

\printglossary

\end{document}
